[{"title":"vue前端面试题","date":"2018-10-30T09:54:49.000Z","path":"2018/10/30/vue前端面试题/","text":"1、active-class是哪个组件的属性？嵌套路由怎么定义？答：vue-router模块的router-link组件。 2、怎么定义vue-router的动态路由？怎么获取传过来的动态参数？答：在router目录下的index.js文件中，对path属性加上/:id。 使用router对象的params.id 3、vue-router有哪几种导航钩子？答：三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件 4、scss是什么？安装使用的步骤是？有哪几大特性？答：预处理css，把css当前函数编写，定义变量,嵌套。 先装css-loader、node-loader、sass-loader等加载器模块，在webpack-base.config.js配置文件中加多一个拓展:extenstion，再加多一个模块：module里面test、loader 4.1、scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？答：css的预编译。 使用步骤： 第一步：用npm 下三个loader（sass-loader、css-loader、node-sass） 第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss 第三步：还是在同一个文件，配置一个module属性 第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss” 有哪几大特性: 1、可以用变量，例如（$变量名称=值）； 2、可以用混合器，例如（） 3、可以嵌套 5、mint-ui是什么？怎么使用？说出至少三个组件使用方法？ 答：基于vue的前端组件库。npm安装，然后import样式和js，vue.use（mintUi）全局引入。在单个组件局部引入：import {Toast} from ‘mint-ui’。组件一：Toast(‘登录成功’)；组件二：mint-header；组件三：mint-swiper 6、v-model是什么？怎么使用？ vue中标签怎么绑定事件？ 答：可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue的model层的data属性。绑定事件： 7、axios是什么？怎么使用？描述使用它实现登录功能的流程？ 答：请求后台资源的模块。npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中 8、axios+tp5进阶中，调用axios.post(‘api/user’)是进行的什么操作？axios.put(‘api/user/8′)呢？ 答：跨域，添加用户操作，更新操作。 9、什么是RESTful API？怎么使用? 答：是一个api的标准，无状态请求。请求的路由地址是固定的，如果是tp5则先路由配置中把资源路由配置好。标准有：.post .put .delete 10、vuex是什么？怎么使用？哪种功能场景使用它？ 答：vue框架中状态管理。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车 11、mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？ 答：一个model+view+viewModel框架，数据模型model，viewModel连接两个 区别：vue数据驱动，通过数据来显示视图层而不是节点操作。 场景：数据操作比较多的场景，更加便捷 12、自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？ 答：全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives 钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新） 钩子函数参数：el、binding 13、说出至少4种vue当中的指令和它的用法？ 答：v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定 14、vue-router是什么？它有哪些组件？ 答：vue用来写路由一个插件。router-link、router-view 15、导航钩子有哪些？它们有哪些参数？ 答：导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave 参数：有to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种 16、Vue的双向数据绑定原理是什么？ 答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 具体步骤： 第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:1、在自身实例化时往属性订阅器(dep)里面添加自己2、自身必须有一个update()方法3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 ps：16题答案同样适合”vue data是怎么实现的？”此面试题。 17、请详细说下你对vue生命周期的理解？ 答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。 创建前/后： 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后：当data变化时，会触发beforeUpdate和updated方法。 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在 18、请说下封装 vue 组件的过程？ 答：首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。 然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。 19、你是怎么认识vuex的？ 答：vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。 答：vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。 应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。 20、vue-loader是什么？使用它的用途有哪些？ 答：解析.vue文件的一个加载器，跟template/js/style转换成js模块。 用途：js可以写es6、style样式可以scss或less、template可以加jade等 21、请说出vue.cli项目中src目录每个文件夹和文件的用法？ 答：assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件 22、vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？ 答：第一步：在components目录新建你的组件文件（smithButton.vue），script一定要export default { 第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’ 第三步：注入到vue的子组件的components属性上面,components:{smithButton} 第四步：在template视图view中使用， 第四步：在template视图view中使用， 问题有：smithButton命名，使用的时候则smith-button。 23、聊聊你对Vue.js的template编译的理解？ 答：简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点） 详情步骤： 首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。 然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等） 然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等） 挑战一下： 1、vue响应式原理？ 2、vue-router实现原理？ 3、为什么要选vue？与其它框架对比的优势和劣势？ 4、vue如何实现父子组件通信，以及非父子组件通信？ 5、vuejs与angularjs以及react的区别？ 6、vuex是用来做什么的？7、vue源码结构","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"微信小程序入门笔记","date":"2018-10-30T08:17:19.000Z","path":"2018/10/30/微信小程序入门笔记/","text":"小程序的框架系统分为两部分：视图层（View）和逻辑层(App Service).配置1.创建之后自动生成4种文件：①json配置文件。 ​ ②js：逻辑层文件 ​ ③wxml。相当于html文件 ​ ④wxss，相当于css样式2.全局配置:app.json page(查看页面路径)、window(设置状态栏、导航栏、标题、窗口背景色）、tabBar(切换页面)、Debug(在控制台页面显示调试信息) 123456789101112131415161718192021eg:\"tabBar\": &#123; \"color\": \"black\", //tab 上的文字默认颜色 \"selectedColor\":\"blue\", //tab 上的文字选中时的颜色 \"backgroundColor\":\"#fff\", //tab 的背景色 \"list\":[&#123; \"pagePath\":\"pages/index/index\", //页面路径，必须在 pages 中先定义 \"text\":\"首页\", //tab 上按钮文字 \"iconPath\":\"images/f1.png\", //图片路径 \"selectedIconPath\":\"images/f1_on.png\" //选中时的图片路径 &#125;,&#123; \"pagePath\": \"pages/statistic/statisitic\", \"text\": \"练习1\", \"iconPath\":\"images/f3.png\", \"selectedIconPath\":\"images/f3_on.png\" &#125;,&#123; \"pagePath\": \"pages/test/test\", \"text\": \"练习2\", \"iconPath\": \"images/loves.png\", \"selectedIconPath\": \"images/lover.png\" &#125;]&#125; 3.页面配置：json文件夹中配置会覆盖app.json中window相同的配置项 逻辑1.APP()函数—-注册下程序，接受一个Object参数，指定小程序的生命周回调等，必须在app.js中调用切只能调用一次。 Object参数： onLauch():生命周期回调–监听小程序初始化（全局只能触发一次） onShow:监听小程序显示，小程序启动时触发或后台进入前台显示时触发 onHide():监听小程序隐藏，小程序从前台进入时触发 onEroor:错误监听函数,页面发生脚本错误时触发 onPageNotFound:页面不存在监听函数 ，打开页面不存在时触发 2.getApp(Object)：全局的 getApp() 函数可以用来获取到小程序 App 实例。 实例：var appInstance = getApp(){ ​ console.log(appInstance.globaIData); } 3.路由：在小程序中所有页面的路由全部由诳街进行管理。 路由的方式有两种：1.调用API 2.使用组件 4.文件作用域：在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。 5.模块化：可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。 视图层1.wxml:数据绑定、列表渲染、条件渲染、模板、事件、引用①数据绑定： 、 id=”item-“ ②列表渲染wx:for eg: 12345678910111213&lt;!-- for遍历九九乘法表 --&gt;&lt;!-- 1*1=1 2*1=2 22=4 2*3=6 3*1=3 32=6 3*3=9 --&gt; &lt;view wx:for=\"&#123;&#123;[1,2,3,4,5,6,7,8,9]&#125;&#125;\" wx:for-item=\"i\"&gt; &lt;view wx:for=\"&#123;&#123;[1,2,3,4,5,6,7,8,9]&#125;&#125;\" wx:for-item=\"j\" style=\"display:inline-block;width:20%;\"&gt; &lt;view wx:if=\"&#123;&#123;j &lt;= i&#125;&#125;\"&gt; &#123;&#123;i&#125;&#125;&#123;&#123;j&#125;&#125;=&#123;&#123;ij&#125;&#125; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; 注意： 花括号和引号之间如果有空格，将最终被解析成为字符串 ③条件渲染:wx:if eg: 123456789101112131415wxml:&lt;view wx:if=\"&#123;&#123;id==1&#125;&#125;\"&gt;第一条&lt;/view&gt; &lt;view wx:elif=\"&#123;&#123;id &gt; 4&#125;&#125;\"&gt;大于4的条件&lt;/view&gt; &lt;view wx:else=\"&#123;&#123;id &gt; 7&#125;&#125;\"&gt;大于7&lt;/view&gt;js:data: &#123; id:8, &#125;----------------------------------------------------&lt;!-- hidden在view中不生效，text有效 --&gt;&lt;text hidden=\"&#123;&#123;true&#125;&#125;\"&gt;这是一段文本&lt;/text&gt;&lt;view hidden=\"&#123;&#123;true&#125;&#125;\"&gt;这是一段文本&lt;/view&gt;----------------------------------------------------&lt;block wx:if=\"&#123;&#123;true&#125;&#125;\"&gt; &lt;view&gt;这里的block标签名可以随便起&lt;/view&gt; &lt;view&gt;相当于一个控制属性&lt;/view&gt;&lt;/block&gt; 注意： block并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。 ④模板:template 1234567891011121314wxml: &lt;template name=\"obj\"&gt; &lt;view&gt;第一个对象：&#123;&#123;a&#125;&#125;&lt;/view&gt; &lt;view&gt;第二个对象：&#123;&#123;b&#125;&#125;&lt;/view&gt; &lt;view&gt;&#123;&#123;temname&#125;&#125;&lt;/view&gt; &lt;/template&gt; &lt;!-- 使用模板 --&gt; &lt;template is=\"obj\" data=\"&#123;&#123;a:1, b:2,temname:name&#125;&#125;\"&gt;&lt;/template&gt; &lt;template is=\"obj\" data=\"&#123;&#123;...obj,temname:name&#125;&#125;\"&gt;&lt;/template&gt; js: data: &#123; obj:&#123; a: 1, b: 3 &#125; &#125; ⑤事件:绑定事件: bindtap | 停止事件冒泡：catchtap ​ 事件中的事件对象：target：事件触发的源头 currentTarget:事件绑定的源头 dateset:事件源组件上由data-开头的自定义属性组成的集合 更多事件可以查看文档，这里就不一一进行说明了 ⑥引用: import:只会引用目标文件夹中的template inclde:只会引用除template外的代码 12345678910eg:&lt;import src=\"item.wxml\" /&gt;&lt;template is=\"item\" data=\"&#123;&#123;name:'一颗小白菜'&#125;&#125;\"&gt;&lt;/template&gt;&lt;include src=\"item.wxml\" /&gt;item.whtml:&lt;view&gt;我是item.wxml&lt;/view&gt;&lt;template name=\"item\"&gt; &lt;text&gt;我是item.wxml中的&#123;&#123;name&#125;&#125;&lt;/text&gt;&lt;/template&gt; 2.wxss: 模块、变量、运算符、语句、数据类型、基础类库尺寸单位：rpx eg:在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。样式导入：@import 必须放在css文件最顶部 内联样式： 选择器：.class、#id、element、element, element、::after、::before 全局样式与局部样式：定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。 组件1.视图容器：view、scroll-view(可滚动视图区域)、swiper(滑块视图容器)、movable-area(可移动区域)、cover-view2.导航：navigator3.媒体组件：audio、video、image、camera、live-player(实时音视频播放)、live-pusher(实时音频录制)4.开放能力：open-data(用于展示微信开放的数据)、web-view(用来承载网页的容器，会自动铺满整个小程序页面)、ad(广告)、official-account(用户扫码打开小程序时，开发者可在小程序内配置公众号关注组件，方便用户快捷关注公众号，可嵌套在原生组件内)5.地图：map 画布:canvas小程序的框架系统分为两部分：视图层（View）和逻辑层(App Service).配置1.创建之后自动生成4种文件：①json配置文件。 ​ ②js：逻辑层文件 ​ ③wxml。相当于html文件 ​ ④wxss，相当于css样式2.全局配置:app.json page(查看页面路径)、window(设置状态栏、导航栏、标题、窗口背景色）、tabBar(切换页面)、Debug(在控制台页面显示调试信息) 123456789101112131415161718192021eg:\"tabBar\": &#123; \"color\": \"black\", //tab 上的文字默认颜色 \"selectedColor\":\"blue\", //tab 上的文字选中时的颜色 \"backgroundColor\":\"#fff\", //tab 的背景色 \"list\":[&#123; \"pagePath\":\"pages/index/index\", //页面路径，必须在 pages 中先定义 \"text\":\"首页\", //tab 上按钮文字 \"iconPath\":\"images/f1.png\", //图片路径 \"selectedIconPath\":\"images/f1_on.png\" //选中时的图片路径 &#125;,&#123; \"pagePath\": \"pages/statistic/statisitic\", \"text\": \"练习1\", \"iconPath\":\"images/f3.png\", \"selectedIconPath\":\"images/f3_on.png\" &#125;,&#123; \"pagePath\": \"pages/test/test\", \"text\": \"练习2\", \"iconPath\": \"images/loves.png\", \"selectedIconPath\": \"images/lover.png\" &#125;]&#125; 3.页面配置：json文件夹中配置会覆盖app.json中window相同的配置项 逻辑1.APP()函数—-注册下程序，接受一个Object参数，指定小程序的生命周回调等，必须在app.js中调用切只能调用一次。 Object参数： onLauch():生命周期回调–监听小程序初始化（全局只能触发一次） onShow:监听小程序显示，小程序启动时触发或后台进入前台显示时触发 onHide():监听小程序隐藏，小程序从前台进入时触发 onEroor:错误监听函数,页面发生脚本错误时触发 onPageNotFound:页面不存在监听函数 ，打开页面不存在时触发 2.getApp(Object)：全局的 getApp() 函数可以用来获取到小程序 App 实例。 实例：var appInstance = getApp(){ ​ console.log(appInstance.globaIData); } 3.路由：在小程序中所有页面的路由全部由诳街进行管理。 路由的方式有两种：1.调用API 2.使用组件 4.文件作用域：在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。 5.模块化：可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。 视图层1.wxml:数据绑定、列表渲染、条件渲染、模板、事件、引用①数据绑定： 、 id=”item-“ ②列表渲染wx:for eg: 12345678910111213&lt;!-- for遍历九九乘法表 --&gt;&lt;!-- 1*1=1 2*1=2 22=4 2*3=6 3*1=3 32=6 3*3=9 --&gt; &lt;view wx:for=\"&#123;&#123;[1,2,3,4,5,6,7,8,9]&#125;&#125;\" wx:for-item=\"i\"&gt; &lt;view wx:for=\"&#123;&#123;[1,2,3,4,5,6,7,8,9]&#125;&#125;\" wx:for-item=\"j\" style=\"display:inline-block;width:20%;\"&gt; &lt;view wx:if=\"&#123;&#123;j &lt;= i&#125;&#125;\"&gt; &#123;&#123;i&#125;&#125;&#123;&#123;j&#125;&#125;=&#123;&#123;ij&#125;&#125; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; 注意： 花括号和引号之间如果有空格，将最终被解析成为字符串 ③条件渲染:wx:if eg: 123456789101112131415wxml:&lt;view wx:if=\"&#123;&#123;id==1&#125;&#125;\"&gt;第一条&lt;/view&gt; &lt;view wx:elif=\"&#123;&#123;id &gt; 4&#125;&#125;\"&gt;大于4的条件&lt;/view&gt; &lt;view wx:else=\"&#123;&#123;id &gt; 7&#125;&#125;\"&gt;大于7&lt;/view&gt;js:data: &#123; id:8, &#125;----------------------------------------------------&lt;!-- hidden在view中不生效，text有效 --&gt;&lt;text hidden=\"&#123;&#123;true&#125;&#125;\"&gt;这是一段文本&lt;/text&gt;&lt;view hidden=\"&#123;&#123;true&#125;&#125;\"&gt;这是一段文本&lt;/view&gt;----------------------------------------------------&lt;block wx:if=\"&#123;&#123;true&#125;&#125;\"&gt; &lt;view&gt;这里的block标签名可以随便起&lt;/view&gt; &lt;view&gt;相当于一个控制属性&lt;/view&gt;&lt;/block&gt; 注意： block并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。 ④模板:template 1234567891011121314wxml: &lt;template name=\"obj\"&gt; &lt;view&gt;第一个对象：&#123;&#123;a&#125;&#125;&lt;/view&gt; &lt;view&gt;第二个对象：&#123;&#123;b&#125;&#125;&lt;/view&gt; &lt;view&gt;&#123;&#123;temname&#125;&#125;&lt;/view&gt; &lt;/template&gt; &lt;!-- 使用模板 --&gt; &lt;template is=\"obj\" data=\"&#123;&#123;a:1, b:2,temname:name&#125;&#125;\"&gt;&lt;/template&gt; &lt;template is=\"obj\" data=\"&#123;&#123;...obj,temname:name&#125;&#125;\"&gt;&lt;/template&gt; js: data: &#123; obj:&#123; a: 1, b: 3 &#125; &#125; ⑤事件:绑定事件: bindtap | 停止事件冒泡：catchtap ​ 事件中的事件对象：target：事件触发的源头 currentTarget:事件绑定的源头 dateset:事件源组件上由data-开头的自定义属性组成的集合 更多事件可以查看文档，这里就不一一进行说明了 ⑥引用: import:只会引用目标文件夹中的template inclde:只会引用除template外的代码 12345678910eg:&lt;import src=\"item.wxml\" /&gt;&lt;template is=\"item\" data=\"&#123;&#123;name:'一颗小白菜'&#125;&#125;\"&gt;&lt;/template&gt;&lt;include src=\"item.wxml\" /&gt;item.whtml:&lt;view&gt;我是item.wxml&lt;/view&gt;&lt;template name=\"item\"&gt; &lt;text&gt;我是item.wxml中的&#123;&#123;name&#125;&#125;&lt;/text&gt;&lt;/template&gt; 2.wxss: 模块、变量、运算符、语句、数据类型、基础类库尺寸单位：rpx eg:在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。样式导入：@import 必须放在css文件最顶部 内联样式： 选择器：.class、#id、element、element, element、::after、::before 全局样式与局部样式：定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。 组件1.视图容器：view、scroll-view(可滚动视图区域)、swiper(滑块视图容器)、movable-area(可移动区域)、cover-view2.导航：navigator3.媒体组件：audio、video、image、camera、live-player(实时音视频播放)、live-pusher(实时音频录制)4.开放能力：open-data(用于展示微信开放的数据)、web-view(用来承载网页的容器，会自动铺满整个小程序页面)、ad(广告)、official-account(用户扫码打开小程序时，开发者可在小程序内配置公众号关注组件，方便用户快捷关注公众号，可嵌套在原生组件内)5.地图：map 画布:canvas","tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"}]},{"title":"前端面试问题总结","date":"2018-10-25T06:50:23.000Z","path":"2018/10/25/前端面试问题总结/","text":"目录 HTML CSS JavaScript jQuery Ajax HTTP Front-end-frame-relative Json-XML localStorage mobile-terminal Modules performance-optimization PS SEO ES6 cross-domain cookie MVC Git data-structure dataBase Handwritten-code computer-basic-knowledge other comprehensive vue react MVVM 浏览器 性能 综合版本 Interview-Questions Front-end-Developer-Questions[question-and-answer-versio]","tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"HTML笔记","date":"2018-10-25T06:02:48.000Z","path":"2018/10/25/HTML笔记/","text":"HTML（HyperText Markup Language，超文本标记语言） 是用来定义网页结构的一种描述语言。 HTML:超文本标记语言 一．标签按照语法分类： 1.单标签：开始标签 &lt;标签名&gt;例如：meta 2.双标签:开始标签/结束标签构成 &lt;标签名&gt;&lt;/标签名&gt; 例如：&lt;head&gt;&lt;/head&gt; 3.注释标签(Ctrl+ / )： &lt;!-- --&gt; 表单控件（属于行内块元素）：文本框 二．按照页面中的呈现效果分类： 1.块元素 特性：可以设置宽高，独占一行。 例如：div p(段落) pre等等;h1-h6\\ 列表标签： 无序列表:ul;li ul下边必须嵌套的是li 有序列表:ol;li ... 项目列表：dl\\dt;dd dl→dt→dd 2.行内元素 特性：在一行内显示，不可以设置宽高。 例如：this is my sister b(加粗);em着重文字；i倾斜;span span标签不可以设置宽高，浮动之后可以设置宽高 3.行内块元素 特性：在一行内显示，可以设置宽高。 例如：img\\表单控件（input） 元素级别： 块元素&gt;行内块元素&gt;行内元素 元素的转换（display） 块元素：block 行内元素：inline 行内块元素：inline-block div.btn{$$}\\19 点tab键同时复制19句 文档流： 从左到右，从上到下 一个元素实际的宽高： 实际的宽度 = border-left+padding-left+width+padding-right+border-right 实际的高度 = border-top+padding-top+height+padding-dottom+border-bottom 元素的嵌套规则： 相同级别可以相互嵌套。级别高的元素可以嵌套元素级别低的元素 属性： 语法：1.位置在哪里？在开始标签中。 2.&lt;meta 属性名(如charset)=&quot;属性值&quot;&gt; 3.&lt;div 属性名=&quot;属性值1 属性值2&quot;&gt; 例如：&lt;div class=&quot;box1 box2&quot;&gt;&lt;/div&gt; 路径的两种方式： 1.绝对路径：从盘符开始的路径； 2.相对路径：一个文件和另一个文件的关系 返回上一级： ../ CSS层叠样式表： 选择器 和 样式 一．选择元素 1.标签选择器:选择页面中所有的标签 语法： 标签名{ 样式名：样式值; 样式名：样式值; ... } div{ width:600px; height:600px; background-color:red; } 2.类名选择器：选择页面中类名为的全部元素。 语法：.类名{ 样式名:样式值; } 3.后代选择器：** 元素一 元素二{ } 4.群组选择器： 元素一,元素二…{ } 5、通用选择器 *{ ​ Width:100px; } 6、交叉选择器：选择类名一样的其中的一个标签 tabName.className{} 7、子类选择器 E&gt;F{} .box &gt;div 8、兄弟选择器 E+F 相邻的兄弟元素 9、伪类选择器（选中元素的一种状态）： 1、：hover{} 选中元素的鼠标移入状态 2、:Link{} 默认时的状态 3、:active{} 跳转点击时的状态 4、:visited{} 访问过后的状态 三．伪元素选择器（选择不存在的元素） 1**、*::before{content:” ”;} ** 在内容之前添加的伪元素（行内元素） 2**、*::after{content:” ”;} ** 在内容之后添加的伪元素** 3**、*::first-letter{content:” ”;} ** 在内容中添加首字母的伪元素 4**、*::first-line{content:” ”;} ** 在内容中添加行的伪元素 定义属性时：必须content:” ”; **转换块元素** 四、结构伪类： .box{}** 1**、.box p:nth-child(1){} 作为box中里面第一个子元素的P标签 2、.box p:nth-last-child(3){} 作为box中里面倒数第三个子元素的P标签 3、.box p:nth-first-child{} 作为box中里面第一个子元素的P标签 4、.box div:nth-of-type(1){} 作为box中里面同类型的第一个子元素的div标签 5、.box div:nth-last-of-type(1){} 作为box中里面同类型的第一个子元素的div标签 6、.box div:nth-first-of-type{} 作为box中里面同类型的倒数第一个子元素的div标签 7、.box div:nth-child(1){} 作为box中里面第一个子元素的div 8、.box div:last-child{} 作为box中里面倒数第一个子元素的div 9、.box div:first-child{} 作为box中里面第一个子元素的div 10、.box div:empty{} 选中一个没有内容的div（一切元素都没有的时候） 11、 html:root{} 选中根元素 12、 .box div:only-child{} 选中元素的唯一元素（比.box div的优先级别高） 13、.box div:only-of-type{} 选中元素的唯一同类型元素 样式表的引入方式： 1.**外链式样式** 2.**嵌入式样式表** .box{ width:200px; height:200px; } 3.**行内样式表** 行内样式优先级最高。嵌入式和外链式的优先级由引入页面中的顺序决定，离元素越近，优先级越高。** A B C D E 1 2 3 3 0 -———————————————————————————————- A style B ID 选择器的数量 C class类名选择器的数量/ 伪类选择器的数量/属性选择器的数量 D 标签选择器的数量/伪元素选择器的数量 E 通用选择器 -————————————————————————————————– ID 选择器的优先级：100（#代表id） 类名选择器的优先级：10 标签选择器的优先级：1 选择器的优先级原则：越具体优先级越高。 五**.盒子模式：** content(width,height) padding(内填充，内容和边框的距离) border(边框) margin（外间距 元素和元素之间的距离） margin:0 auto :**让块元素在父元素中水平居中** text-align:**行内元素水平方向的对齐元素** line-height:120px;**定义行高** margin:50px 100px **上下 左右** margin:50px 100px 50px **上 左右 下** margin:50px 100px 200px 300px **上右下左** 盒子模型中的一些问题：** 默认情况下大部分元素的**margin\\padding都为0，但是有一些元素的margin\\padding不为 0.比如说：h1-h6标签\\P\\body\\ul,li\\ol,li\\dl dt dd** 相邻的两个块元素的**margin值会重合。值会取得最大值。** 行内元素的**margin只有左右没有上下。** margin**可以设置为负数，padding不可以。** 当两个元素发生嵌套关系，如果父元素没有上边边框，上**padding值，父子之间没有其他内容。此时子元素的margin-top值回作用到父元素身上。（解决方法一：给父元素加padding-top来代替子元素加margin-top；解决方法二：给父元素添加overflow:hidden/*超出部分：隐藏*/）** 六．**float浮动** 原理：让元素脱离文档流。 解决：块元素独占一行。 浮动的子元素撑不开父元素 1.给父元素添加 overflow:hidden; 2clear:left/right/both;在父元素最后添加一个拥有清除浮动属性的子元素. .box::affter{ Content:””; Display:block; Clear:both; } 浮动之后宽度会自动参照内容。 字体：font-weight:normal 正常不加粗 bold加粗 100-900（单位，加粗程度） Padding-left:2em; 当前字体的2倍 em指字数的二倍 所有字体的设置都可以被继承** auto:高度参照内容元素 宽度参照父元素 子元素的border+padding+margin值不会大于父元素 box-sizing:border-box **容器的宽高变成实际尺寸** cursor**：pointer;鼠标样式手型** List-style:none; **清除列表样式** Border-radius:3px **边框的半径** Max-height **最大高度** Min-height **最小高度** Display:none; **超出部分消失 // display:block; 超出部分出现** Visibility:hidden ; **超出元素隐藏 // visibility:visible 超出部分出现** CSS3**样式** 1.**过渡（transition）：** transition:all /width 1s ease/ease-in/../linear[匀速] 1s; 样式 过渡时间 [时间函数,默认ease] [延迟] Transition-property:width height; Transition-duration:1s; Transition-timing-function:linear; Transition-timing-function:cubic-bezier(0.98,0.38,0.21,1.06) 贝塞尔曲线 Transition-delay:initial; Transition-delay:1s;** 2D**（transform）** (1)**平移** 样式名：**transform;** 样式值：**translate;(x,y)平移 / translateX(number); /translateY(number);** 旋转** Rotate(value); **角度45deg/-45deg rad弧度 turn圈数** (3)**缩放** Scale(x,y) scaleX(value) ScaleY(valuer)** 斜切** Skew(x,y) SkewX(value) skexY(value)** Box-shadow:0 10px 10px 5px rgba(0,0,0,1) ** 阴影：**Box-shadow** Box-shadow:;** X**轴偏移量** Y**轴偏移量** 阴影的模糊程度** 阴影的大小** 阴影的颜色** [inset]** 3D** 场景：**Perspective:500px; 灭点 /perspective-origin：x,y 观察者的位置** 平移：沿**z轴平移 Transform:translateZ(length); trsnslate3d(length,length,length)** 旋转：transform:rotateY/X/Z(*turn); / rotate3d(0,0,0,angle) / Transform-origin: Top content left; rotate3d(1,0,1,45deg) 改变圆点 Transform-style:preseve-3d 保持3d效果 动画： 123456789101112131415161718@keyframes animation1(*动画1)&#123;From/0%&#123; Width:100px; Height:100px; Border-radius:50%;&#125;To/100%&#123; Width:200px; Height:200px; Border-radius:0;&#125;.box&#123; Animation:animation1 2s ease 0s; Forwards 2;&#125;&#125; 渐变：background-image 线性渐变：background-image:repeating-linear-gradient(to right/45deg, red 50%,green,blue); 重复渐变 默认上 径向渐变：background-image：repeating-radial-gradient(red 50%,green 70%); 颜色的表示方式： 颜色的单词：black,pink,yellow等等； 十六进制的色值：#000 #fff #202020等等； RGB(red,green,blue的程度（0-255）)：RGB(255,0,0)红色 RGB(0 255 0)绿色 RGB(000) 黑色 RGB(255,255,255)白色 Rgba([0-255] [0-255] [0-255] [0-1]设置成0为透明色) 背景图** Background-image:url(“../img/**.jpg”) Background-color:pink;（背景颜色） Background-size:200px auto:背景图尺寸 仅有200px 值为背景图的宽度 Background-size:cover; 覆盖铺买整个界面 Background-size:contain; 背景图片优先，最大程度的呈现图片（背景图为图片的原尺寸） Background-repeat:no-repeat; 取消重复设置 Background-repeat:repeat-x/y; 在x轴或y轴重复设置 Background-position:100px 100px; 背景图片的定位(100px为x轴和y轴的数值) Background-position:right bottom; 背景图片在右下角 Background-position:right ; 背景图片在右中 Background-origin:border-box; 盒子背景图的渲染位置 Border-box 边框内 / padding-box 内填充内（默认） / content-box 内容内 Background-clip:content-box; 盒子背景图裁剪位置 Border-box 边框外裁剪（默认） padding-box content-box Background-attachment:fixed(固定); 图片精灵（雪碧图） .fanke1{ ​ width: 113px; ​ height: 42px; ​ border: 1px solid red; ​ text-align: center; ​ margin: 0 auto; ​ margin-top: 200px; ​ background-image:url(‘../img/spritesbgtop.png’) ; ​ background-repeat: no-repeat; ​ background-position: 0 -581px; } 定位**(position)脱离文档流：** 相对定位**(relative)** 相对自身去定位。保留原来的位置（文档层中的位置）** 绝对定位**(absolute)** 相对于“拥有定位属性（样式）”的父元素去定位。如果父元素没有定位属性，会一直向上一级寻找，直到找到拥有定位属性定位的元素停止。如果一直找不到相对于**html定位。完全脱离文档流。** 3.**固定定位(fixed)** 相对于浏览器的四个边去定位**.完全脱离文档流** 定位的元素会多出五个样式：** Top right bottom left z-index(**层级)** 定位的居中方式：** 水平居中** position:absolute;** Top:0;** Left:50%;** Margin-left:50%;** position:absolute;** Top:0;** Left:0;** Right:0;** Margin:0 auto;** ·**left权重比right权重高** Top**权重比bottom权重高** 垂直居中** (1)Position:absolute;** Top:0;** Margin-top:-50px;** (2)Position:absolute;** Top:0;** Bottom:0;** Margin:0 auto; ** 绝对居中** ** (1)position:absolute** Top:50%;** Margin-top:-50px;** Left:50%;** Margin-left:-50pxs;** (2)position:absolute** Top:0;** Right:0;** Bottom:0;** Left:0;** Margin:auto;** *\\Cursor:pointer 鼠标经过时变成手型** *\\list-style:none 清除列表样式** Outline:none ** *\\border-radius:50% 矩形转换为圆** .box:hover .bottom{} box**的子元素移入【只能是子元素】 ** Opacity:0/1;**透明度** Ctrl+f**查找** ** 移动端口** 视口：viewport 缩放：Initial-scale=1.0,maximum-scale=1.0,user-scalable=0(不允许用户进行缩放) 布局视口：屏幕分配出来可供用户布局的范围。一般是980px。 视觉视口：设备屏幕的大小。 理想视口： 像素 物理像素：屏幕理所能呈现的最小颜色单元。 逻辑像素：固定的大小 css像素：css样式表里所写的像素 Web css像素==逻辑像素==物理像素（浏览器不放大的情况下） 移动端&gt;css像素&gt;逻辑像素 弹性布局：**display:flex** 父元素称作为容器，子元素称作为项目，宽度被子元素平分，高度为 auto参照父元素 引入方式：@import url(“base css”) 是否换行：**flex-wrap:**wrap（换行）/no warp(默认不换行)/warp-reverse（反向换行，第一行在下） 在主轴的对齐方式：**justify-content**:flex-start（轴开始的位置）/center（轴中心）/flex-end（轴结束位置）/Space-between（两端对齐）/space-around(平均分配) ** 主轴方向排列：**flex-direction:**row(行) row-reverse(行反向)/ column(列) column-reverse 主轴方向row从左到右，row-reverse从右到左 Column从上到下 column-reverse 从下到上 项目在单行的对齐方式，单行操作:align-items:**flex/flex-end/center/baseline Flex 轴开始 Center 轴中心（在一行内居中） Flex-end 轴结束 Baseline 基线 项目在多行的对齐方式，多行操做：Align-content:**flex-start/center/flex-end/space-between/space-around 对项目的操作：**order**:0(默认为0，容器中的项目从小到大排列) 放大项目：**flex-grow:**0;(默认为不放大为0) 缩小项目：**flex- Shrink:**1;(默认为1) 项目自身对齐：Align-self:**flex-start/center/flex-end/space-between/space-around; 项目宽度：Flex-basis:200px;相当于width:200px; Git分布式版本控制工具 工作区 暂存区（本地仓库） 远程仓库 Cd 打开指令后边空格 Cd 打开指令后边空格Git分布式版本控制公具 Cd 打开指令后边空格Git分布式版本控制公具工作区 暂存区(本地仓库) 远程仓库 Cd 打开指令后边空格Git分布式版本控制公具工作区 暂存区(本地仓库) 远程仓库Git clone克隆 git clone http//. Cd 打开指令后边空格Git分布式版本控制公具工作区 暂存区(本地仓库) 远程仓库Git clone克隆 git clone http//.Git add . (添加 .代表新建以及修改过得文件) Cd 打开指令后边空格Git分布式版本控制公具工作区 暂存区(本地仓库) 远程仓库Git clone克隆 git clone http//.Git add . (添加 .代表新建以及修改过得文件)Git Status( 查看创建的文件状态) git commit –m”初始化” Cd 打开指令后边空格Git分布式版本控制公具工作区 暂存区(本地仓库) 远程仓库Git clone克隆 git clone http//.Git add . (添加 .代表新建以及修改过得文件)Git Status( 查看创建的文件状态) git commit –m”初始化”Git push 回车(推送) git log 查看历史版本 git reset –hard Cd 打开指令后边空格Git分布式版本控制公具工作区 暂存区(本地仓库) 远程仓库Git clone克隆 git clone http//.Git add . (添加 .代表新建以及修改过得文件)Git Status( 查看创建的文件状态) git commit –m”初始化”Git push 回车(推送) git log 查看历史版本 git reset –hard桌面创建coding文件夹 Cd 打开指令后边空格Git分布式版本控制公具工作区 暂存区(本地仓库) 远程仓库Git clone克隆 git clone http//.Git add . (添加 .代表新建以及修改过得文件)Git Status( 查看创建的文件状态) git commit –m”初始化”Git push 回车(推送) git log 查看历史版本 git reset –hard桌面创建coding文件夹Cd空格(coding文件夹地址) Cd 打开指令后边空格Git分布式版本控制公具工作区 暂存区(本地仓库) 远程仓库Git clone克隆 git clone http//.Git add . (添加 .代表新建以及修改过得文件)Git Status( 查看创建的文件状态) git commit –m”初始化”Git push 回车(推送) git log 查看历史版本 git reset –hard桌面创建coding文件夹Cd空格(coding文件夹地址)Git空格clone空格coing网页地址 Cd 打开指令后边空格Git分布式版本控制公具工作区 暂存区(本地仓库) 远程仓库Git clone克隆 git clone http//.Git add . (添加 .代表新建以及修改过得文件)Git Status( 查看创建的文件状态) git commit –m”初始化”Git push 回车(推送) git log 查看历史版本 git reset –hard桌面创建coding文件夹Cd空格(coding文件夹地址)Git空格clone空格coing网页地址Cd空格xiaomi 5. git add空格. ** H5表单控件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;Form action=”index.php” method=”/get/post” enctype=\"multipart/form-data\"&gt; 提交方式 &lt;input type=”text”name=”username” value=”” required minlength=”5” maxlength=”10” readonly auto/autocomplete =”off”(自动补充开关)&gt;&lt;br&gt; 属性 名字 属性值 必填项 最少输入字符数 最多输入字符数 只读密码:&lt;input type=”password” name=”password” value=”123456”&gt;&lt;br&gt;男:&lt;input type=”radio” name=”sex”value=”1”&gt;女:&lt;input type=”radio” name=”sex” value=”0”&gt;&lt;br&gt;爱好：&lt;input type=”checkbox” checked(默认选中) name=”hobby” value=”0”&gt;游泳 &lt;input type=”checkbox” name=”hobby” value=”1”&gt;轮滑&lt;input type=”checkbox” name=”hobby” value=”2”&gt;篮球&lt;br&gt;文件：&lt;input type=”file” multiple(多选)&gt;下拉框： &lt;select name=”city” id=”” size=”2”(框内显示个数)&gt; &lt;option value=”0”&gt;上海&lt;/option&gt; &lt;option value=”1” selected(默认选中)&gt;北京&lt;/option&gt; &lt;option value=”2”&gt;广州&lt;/option&gt; &lt;/select&gt;简介：&lt;textarea name=”info” id =”” cols=”30”(字数) rows=”10”（行）&gt;&lt;/textarea&gt;数字：&lt;input type=”number” name=”number” max=”10” min=”0” step=”2”(步进值)&gt;滑块：&lt;input type=”range” name=”number” max=”10” min=”0” step=”2”(步进值) value=”1”&gt;日历：&lt;input type=”date”&gt;/&lt;input type=”month”&gt;/&lt;input type=”week”&gt;/&lt;input type=”time”&gt; 年 年+月 年+周 年+时间颜色 ：&lt;input type=”color”&gt;网址：&lt;input type=”url”required&gt;邮箱：&lt;input type=”email”&gt;电话：&lt;input type=”tel”&gt;搜索：&lt;input type=”search”&gt;提示：&lt;input type=”text” value=”” autofocus placeholder=”请输入用户名”&gt; 提示信息提交:&lt;input type=”submit”disabled (不可使用)&gt; 按钮：&lt;input type=”button”&gt;重置：&lt;input type=”reset”&gt;&lt;label for=\"IDName\"&gt;姓名：&lt;/label&gt;&lt;/form&gt;","tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"PS笔记","date":"2018-10-25T05:37:05.000Z","path":"2018/10/25/ps笔记/","text":"2017.10.9 PS笔记 1.像素/分辨率：屏幕显示一般使用72PPI（密度） 印刷一般使用300PPI RGB:红，绿，蓝 用于屏幕显示 CMYK:青，品红，黄，黑 用于彩色印刷 2.存储格式PSD格式 photoshop格式，保存图层等，可以多次编辑图像 JPG/JPEG:图片格式，不支持透 GIF:支持透明，有损压缩 PNG：存储空间小，支持透明，无损压缩 3.快捷键:新建画布：Ctrl+N 打开文件：ctrl+o 找图层：Ctrl 加选图层：ctrl 多选图层：shift 新建图层：Ctrl+shift+alt+n 移动图层：ctrl+『上移 **Ctrl+』下移** 图层置顶或者置底：Ctrl+shfit+『』 4.填充色:默认前景色和背景色：D 切换前景色背景色：X 前景色：alt+delete 背景色：Ctrl+delete 原位复制：Ctrl+j 复制键：alt 选中选区：ctrl 点击小方块 取消选区：Ctrl+D 选区换色方法适用于矩形，正方形 羽化：shift+f6 返回一步：Ctrl+Z 连续返回：ctrl+alt+z 按住AIT键，转动鼠标滚轮，放大缩小画布 放大缩小画布：Ctrl+ + 或 - 按住空格键，拖动画布 打开或关闭标尺：Ctrl+R 调整选区大小：Alt+S+t 自由变换：Ctrl+T 反选：Ctrl+Shift+I 复制变换：Ctrl+alt+shift+T 新建组：Ctrl+G 路径变选区：Ctrl+回车键 关闭或打开路径：Ctrl+Shift+H 按住ALT键可同时缩放物体两边的宽度 裁剪出的背景颜色为，背景色中的颜色 魔棒容差值越小越精细 切片工具存储WEB格式为：PNG-24 按住Alt键选择可见的图层。其他图层就可以全部关闭。反之打开 矢量图 矢量图经过放大缩小不会失真 双击缩略图可更改颜色 ** 5.工具钢笔工具： 路径： ALT键点击锚点可以删除其中的一个方向点，CTRL结束绘制 ALT**:**锚点在最后一个时，点击锚点可以重新绘制路径，锚点在中间是时，点击锚点可以去点把手，曲线变质先（尖角）；拖动锚点时，可以直线变回曲线。可以调整并断开单侧把手。 Ctrl:可以拖动锚点；可以调整双侧把手 画笔工具：颜色为前景色，按住ALT键，点击右键左右缩放大小* 【】调正画笔大小 6.滤镜祛痘： 1.背景拷贝 污点修复工具大概祛下痘 通道选择我绿色拷贝 滤镜-其他-高反差保留（选择数值6） 图像-应用图像-线性光（重复直到无差时选择重叠） 选择通道绿色拷贝选区-返回图层-反选 7.图层样式-曲线（微调，觉得不够重复以上步骤） ** 素描：1.复制图层，去色 **2.复制图层，反相** ​ 3.调整图层混合模式，正常变为颜色渐大或者线性简淡 ​ 4.滤镜-其他-最小值（1-3） ​ 5.图层样式，混合选项中，在颜色混合带中，按住ALT键进行调整（下一个图层·） ​ 6.添加蒙版，在蒙版上添加杂色（200-300）选中蒙版-动感模糊 ** 字体： 行间距取字号的1.5到2倍（80像素的字体应在120到160之间） 排版：用英文时，取左对齐；中文使用最后一行左对齐 避头尾法则设置，一定要设置宽松严格都可以 字体：中文一般使用微软雅黑，英文使用HELVETICA ​ 苹方 San Farncisco 画图技巧 画同心圆： ctrl+r标尺，在横纵标尺的交叉部分，和鼠标十字相重合，鼠 标左键+shift+alt画同心圆。 同轴（中心）旋转效果 1.自由变换：Ctrl+T 2.按住ALT键调整重心位置 3.调整旋转度数 4.复制变换：Ctrl+alt+shift+T 作业中水温表彩色圆环的画法：先画一个圆只描边不填充，然后用标尺架一个十字，套索画出选区填充，之后剪贴蒙版，依次画 关于蒙版 图片添加蒙版 2.选择画笔涂抹（黑色删除，灰色恢复） 图层样式： 图层样式中如果要在渐变叠加上剪贴蒙版要在混合选项中 将剪贴图层混合成组前面的对勾取消，内部效果前面打勾 \u0010","tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"BlueLake博客主题的安装及详细配置","date":"2018-10-25T03:23:02.000Z","path":"2018/10/25/BlurLake博客主题的安装及详细配置/","text":"这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能和回到顶部效果。这个主题只是一个小小的雏形，期待您来帮助它成长。 在阅读本文之前，假定您已经成功安装了Hexo，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 需要特别注意的是Hexo有两个_config.yml配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为根_config.yml；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为主题_config.yml。 1. 安装您可以直接到BlueLake发布页下载，然后解压拷贝到themes目录下，修改配置即可。 您可以直接到BlueLake发布页下载，然后解压拷贝到themes目录下，修改配置即可。不过我还是推荐使用GIT来checkout代码，之后也可以通过git pull来快速更新。 1.1 安装主题在根目录下打开终端窗口： 12git bash$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake 1.2 安装主题渲染器BlueLake是基于jade和stylus写的，所以需要安装hexo-renderer-jade和hexo-renderer-stylus来渲染。 123git bash$ npm install hexo-renderer-jade@0.3.0 --save$ npm install hexo-renderer-stylus --save 1.3 启用主题打开根_config.yml配置文件，找到theme字段，将其值改为BlueLake(先确认主题文件夹名称是否为BlueLake)。 12根_config.yml_config.ymltheme: BlueLake 1.4 验证首先启动 Hexo 本地站点，并开启调试模式： 12git bash$ hexo s --debug 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 1.5 更新主题今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。 123git bashcd themes/BlueLakegit pull 2. 配置2.1 配置网站头部显示文字打开根_config.yml，找到： 12345根_config.yml_config.ymltitle: subtitle: description: author: title和subtitle分别是网站主标题和副标题，会显示在网站头部；description在网站界面不会显示，内容会加入网站源码的meta标签中，主要用于SEO；author就填写网站所有者的名字，会在网站底部的Copyright处有所显示。 2.2 设置语言该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下： 12根_config.yml_config.ymllanguage: zh-CN 2.3 设置菜单打开主题_config.yml，找到： 1234567891011121314主题_config.ymlthemes/BlueLake/_config.ymlmenu: - page: home directory: . icon: fa-home - page: archive directory: archives/ icon: fa-archive # - page: about # directory: about/ # icon: fa-user - page: rss directory: atom.xml icon: fa-rss 主题默认是展示四个菜单，即主页home，归档archive，关于about，订阅RSS；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。 主题默认是展示四个菜单，即主页home，归档archive，关于about，订阅RSS；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。每个页面底部的footer中联系博主的三个图标分别是邮箱，微博主页链接地址，GitHUb个人页链接地址，直接使用主题_config.yml中about页面的配置，若不需要about页面，只需要如下配置就好： 123456主题_config.ymlthemes/BlueLake/_config.yml# About page about: email: ## 个人邮箱 weibo_url: ## 微博主页链接地址 github_url: ## github主页链接地址 2.3.1 添加about页此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面： 12git bash$ hexo new page 'about' 打开主题_config.yml，补全关于我页面的详细信息： 123456789主题_config.ymlthemes/BlueLake/_config.yml# About page about: photo_url: ## 头像的链接地址 email: ## 个人邮箱 weibo_url: ## 微博主页链接地址 weibo_name: ## 微博用户名 github_url: ## github主页链接地址 github_name: ## github用户名 当然您也可以自定义重新布局about页面，只需要修改layout/page.jade模板就好。 2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件在根目录下打开命令行窗口： 1234git bash$ npm install hexo-generator-feed --save$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 添加主题_config.yml配置： 123456789101112131415主题_config.ymlthemes/BlueLake/_config.ymlPlugins: hexo-generator-feed hexo-generator-sitemap hexo-generator-baidu-sitemapfeed: type: atom path: atom.xml limit: 20sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 2.4 添加本地搜索默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件hexo-generator-json-content来创建JSON数据文件： 12git bash$ npm install hexo-generator-json-content@2.2.0 --save 然后在根_config.yml添加配置： 12345678910111213141516171819根_config.yml_config.ymljsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 最后在主题_config.yml添加配置： 12主题_config.ymlthemes/BlueLake/_config.ymllocal_search: true 2.5 修改站点图标站点图标存放在主题的Source目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。 站点图标存放在主题的Source目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。您需要准备一张ico格式并命名为 favicon.ico ，请将其放入hexo目录的source文件夹，建议大小：32px X 32px。 站点图标存放在主题的Source目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。您需要准备一张ico格式并命名为 favicon.ico ，请将其放入hexo目录的source文件夹，建议大小：32px X 32px。您需要为苹果设备添加网站徽标，请命名为 apple-touch-icon.png 的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。 站点图标存放在主题的Source目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。您需要准备一张ico格式并命名为 favicon.ico ，请将其放入hexo目录的source文件夹，建议大小：32px X 32px。您需要为苹果设备添加网站徽标，请命名为 apple-touch-icon.png 的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。(有很多网站都可以在线生成ico格式的图片。) 2.6 添加站点关键字请在hexo目录的根_config.yml中添加keywords字段，如： 12345678根_config.yml_config.yml# Sitetitle: Hexosubtitle: 副标题description: 网站简要描述,如：Charles·Zheng's blog.keywords: 网站关键字, key, key1, key2, key3author: Charleslanguage: zh-CN 2.7 其他配置主题_config.yml的其他配置 show_category_count——是否显示分类下的文章数。 widgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。主题_config.ymlthemes/BlueLake/_config.ymlshow_category_count: true widgets_on_small_screens: true 3.集成第三方服务3.1 添加评论目前主题集成六种第三方评论，分别是多说评论、Disqus评论、来必力评论、友言评论、网易云跟帖评论、畅言评论，多说马上就要停止服务了，友言好像也没怎么维护,目前我已把自己的博客评论从多说转移到畅言了，在国内目前网易云跟帖和畅言还不错。 注册并获得代码。 若使用多说评论，注册多说后获得short_name。 若使用Disqus评论，注册Disqus后获得short_name。 若使用来必力评论，注册来必力,获得data-uid。 若使用友言评论，注册友言,获得uid。 若使用网易云跟帖评论，注册网易云跟帖,获得productKey。 若使用畅言评论，注册畅言，获得appid，appkey。 配置主题_config.yml：主题_config.ymlthemes/BlueLake/_config.yml#Cmmentscomment: duoshuo: ## duoshuo_shortname disqus: ## disqus_shortname livere: ## 来必力(data-uid) uyan: ## 友言(uid) cloudTie: ## 网易云跟帖(productKey) changyan: ## 畅言需在下方配置两个参数，此处不填。 appid: ## 畅言(appid) appkey: ##畅言(appkey) 3.2 百度统计 登录百度统计，定位到站点的代码获取页面。 复制//hm.baidu.com/hm.js?后面那串统计脚本id(假设为：8006843039519956000) 配置主题_config.yml:主题_config.ymlthemes/BlueLake/_config.ymlbaidu_analytics: 8006843039519956000 注意： baidu_analytics不是你的百度id或者百度统计id 注意： baidu_analytics不是你的百度id或者百度统计id如若使用谷歌统计，配置方法与百度统计类似。 3.3 卜算子阅读次数统计12主题_config.ymlthemes/BlueLake/_config.ymlbusuanzi: true 若设置为true将计算文章的阅读量(Hits)，并显示在文章标题下的小手图标旁。 3.4 微博秀微博秀挂件的代码放在layout/_widget/weibo.jade下，需要您去微博开放平台获取您自己的微博秀代码来替换。 登录微博开放平台，选择微博秀。 为了与主题风格统一，作如下配置 基础设置：高400px；勾选宽度自适应；颜色选择白色； 样式设置：主字色#333；链接色#40759b；鼠标悬停色#f7f8f8； 模块设置：去掉标题、边框、粉丝的勾选框，只留微博。 复制代码里src=&quot;&quot;里引号包裹的内容，替换到layout/_widget/weibo.jadeweibo.jadelayout/_widget/weibo.jade.widget .widget-title i(class=&#39;fa fa-weibo&#39;)= &#39; &#39; + __(&#39;新浪微博&#39;) iframe(width=&quot;100%&quot;,height=&quot;400&quot;,class=&quot;share_self&quot;,frameborder=&quot;0&quot;,scrolling=&quot;no&quot;,src=&quot;http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=400&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=5&amp;isTitle=0&amp;noborder=0&amp;isWeibo=1&amp;isFans=0&amp;uid=1700139362&amp;verifier=85be6061&amp;colors=d6f3f7,ffffff,333,40759b,f7f8f8&amp;dpc=1&quot;)这只是为了和主题的风格统一，当然您也可以自由随意发挥。注意：最主要是是要把src里uid=和verifier=后面的字段替换为您自己代码里的就好。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"2分钟了解Markdown语法","date":"2018-10-24T06:36:32.000Z","path":"2018/10/24/2分钟了解Markdown语法/","text":"Markdown 就是一种轻量级的标记语言（Lightweight Markup Language），用人话说就是，普通的文本加上简单的排版或格式化语法（特殊标记），和 HTML，RTF 类似，只是 Markdown 的语法非常简单。Markdown 编写工具很多，在线的也有，很多编程开发工具都支持。需要知道，Markdown 语法没有标准，取决于 Markdown 渲染引擎，各个系统略微有差异。 下面直接介绍 Markdown 的基本语法： 大小不同的标题 Heading1234567891011# 大小不同的标题 Heading## 标题 1 Heading 1### 标题 2 Heading 2#### 标题 3 Heading 3##### 标题 4 Heading 4###### 标题 5 Heading 5 标题 1 Heading 1标题 2 Heading 2标题 3 Heading 3标题 4 Heading 4标题 5 Heading 5黑体字 strong12这是个**黑体字 strong**这也是个**黑体字 strong** 这是个黑体字 strong这也是个黑体字 strong 斜体字 italic12这是个*斜体字 italic*这也是个*斜体字 italic* 这是个斜体字 italic这也是个斜体字 italic 删除线 strikethrought1~~加一条删除线 strikethrought~~ 加一条删除线 strikethrought 无序列表 unordered list*，+，- 都可以表示无序列表。 12345678- 美国- 俄罗斯- 英国- 法国- 中国 - 北京 - 上海 - 广州 美国 俄罗斯 英国 法国 中国 中国_ 北京 中国_ 北京_ 上海 * 广州 有序列表 ordered list1234567891. 个2. 十3. 百4. 千5. 万 1. 十万 2. 百万 3. 千万6. 亿 个 十 百 千 万 十万 百万 千万 亿 水平分隔线 horizontal rule三个-或者三个_ 123------ 链接 link1[点击就去 Google](https://www.google.com) 点击就去 Google 参考链接 ref link如果链接需要多次出现，可以定义链接，然后多次引用。 123[点击去 Google 第一次][goolge][点击去 Google 第二次][goolge][Goolge]:https://www.google.com 点击去 Google 第一次 &gt; 点击去 Google 第二次 点击去 Google 第一次 &gt; 点击去 Google 第二次 图片 image1![翠玉白菜图](https://img.alicdn.com/imgextra/i4/0/T1bMbTFzlcXXXXXXXX_!!0-item_pic.jpg_50x50.jpg) 引用块 blockquote1&gt; 这是个引用块：小李他妈的飞刀 这是个引用块：小李他妈的飞刀 表格 table| 控制分列，-控制分行，: 控制对齐方式，左右或居中。 12345| 职工号 | 姓名 | 年龄 || :----: | :--- | :--: || 1 | 张三 | 20 || 2 | 李四 | 30 || 3 | 王二 | 40 | 职工号 姓名 年龄 1 张三 20 2 李四 30 3 王二 40 转义markdown 支持在特殊字符前面插入\\，插入之后，将不再解析这些字符，而是原样输出。 12这个不是\\# 标题这个不是\\*\\*黑体字\\*\\* 这个不是# 标题 这个不是# 标题这个不是黑体字 代码块猿必备，上面已经展示了，用三个123456789&gt; \\``` &gt; # this is code block&gt;&gt; \\``` &gt; # this is code block&gt; print “Hello, world.”&gt;&gt; \\``` &gt; # this is code block&gt; print “Hello, world.”&gt; \\ HexoHexo 有一些扩展 Markdown 功能，需自行安装插件等： Emoji 表情 播放器 LaTeX/MathJax UML 图 时序图 Next 主题的扩展","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]},{"title":"Hello World","date":"2018-10-22T08:20:15.976Z","path":"2018/10/22/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 这是一篇如何搭建hexo的傻瓜文档：hexo从零开始到搭建完整","tags":[]},{"title":"webpack","date":"2018-03-20T03:07:46.000Z","path":"2018/03/20/webpack/","text":"为什么使用webpack随着互联网的日益发展现在的网页越来越像是一个功能丰富的应用，其中包含了大量的js代码和各种各样相互依赖的包。为了能够简化开发的复杂度，前端社区里涌现出很多的实践方法。 模块化，将复杂的程序细化成为小的文件 类似于TypeScript这种在js基础上扩展出来的语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别； sass less 等css的预编译器 模块化的概念请参考webpack module这些额外的改进确实大大的提高了我们的开发效率，但是利用他们开发的文件往往需要额外的配置才能被浏览器所能够识别，而手动处理有十分的繁琐，于是就出现了类似于webpack之类的工具。 什么是webpackwebpack可以看做是一个模块打包机，它做的事情是：分析你项目结构，找到javascript模块和其他浏览器不能够识别的语言(scss less),并将其转换和打包为合适的格式供浏览器使用。 webpack的工作模式webpack的工作方式是：把你的项目当做是一个整体，通过一个给定的主文件(index.js)，从这个文件开始找到你项目的所有依赖文件，使用loaders处理他们，最后打包为一个或者多个浏览器能够识别的文件。webpack想比较于其他的前端自动化处理工具速度更快处理的文件类型更多。 核心概念(4) 入口(entry) 出口(output) loader 插件(plugins) 入口入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理，最后输出到称之为 bundles 的文件中。 出口output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件。你可以通过在配置中指定一个 output 字段，来配置这些处理过程 loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。 在更高层面，在 webpack 的配置中 loader 有两个目标： test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。 use 属性，表示进行转换时，应该使用哪个 loader。 插件loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。 开始使用webpack安装webpack 新建一个空的文件夹(uek)，在改文件夹中建立package.json文件。这是一个标准的npm说明文件，里面包含着大量的信息，包括当前项目的依赖模块，自定义脚本任务等等。在终端中使用npm init命令可以自动创建这个 package.json文件。输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，不过不用担心，如果你不准备在npm中发布你的模块，这些问题的答案都不重要，回车默认即可。 package.json文件准备就绪，我们在本项目中安装webpack作为依赖包 12npm install webpack@3.6.0 --save-devnpm install webpack@3.6.0 --save-dev -g 在uek文件夹中，创建app文件夹和public文件夹。app文件夹中放原始数据和我们将写的JavaScript模块，public文件夹用来存放之后供浏览器读取的文件（包括使用webpack打包生成的js文件以及一个index.html文件）。 index.html –放在public文件夹中; Greeter.js– 放在app文件夹中; main.js– 放在app文件夹中; 我们在index.html文件中写入最基础的html代码，它在这里目的在于引入打包后的js文件（这里我们先把之后打包后的js文件命名为bundle.js，之后我们还会详细讲述）。 1234&lt;body&gt; &lt;div id=\"root\"&gt; &lt;/div&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt; 我们在Greeter.js中定义一个返回包含问候信息的html元素的函数,并依据CommonJS规范导出这个函数为一个模块： 12345module.exports = function() &#123; var greet = document.createElement('div'); greet.textContent = \"Hi there and greetings!\"; return greet;&#125;; main.js文件中我们写入下述代码，用以把Greeter模块返回的节点插入页面 12const Greet = require('./Greet.js');document.querySelector('#root').appendChild(Greet()); 在配置文件中使用webpackWebpack拥有很多其它的比较高级的功能（loaders、plugins），这些功能其实都可以通过命令行模式实现，但这样不太方便且容易出错的，更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的JavaScript模块，我们可以把所有的与打包相关的信息放在里面。继续上面的例子来说明如何写这个配置文件，在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，我们在其中写入如下所示的简单配置代码，目前的配置主要涉及到的内容是入口文件路径和打包后文件的存放路径。 1234567module.exports = &#123; entry: __dirname + \"/app/main.js\",//已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/public\",//打包后的文件存放的地方 filename: \"bundle.js\"//打包后输出文件的文件名 &#125;&#125; 在终端输入命令 webpack（全局安装），然后你会在public文件夹下看到打包文件bundle.js。这中方式我们就可以省去烦人的命令行。如果我们连webpack命令都可以不用，会感觉更爽。 更快捷的执行任务打包在命令输入命令需要代码类似于 webpack（非全局这样的路径其实是比较麻烦的，值得庆幸的是npm可以引导任务执行，对npm进行配置后可以在命令中使用简单的npm start命令来代替上面繁琐的命令。在package.json中对script对象进行设置即可，设置如下: 123456789101112131415&#123; \"name\": \"demo2\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"webpack\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"webpack\": \"^3.6.0\" &#125;&#125; npm的start命令是一个特殊的脚本名称，其特殊性体现在，在命令中使用npm start就可以执行它对应的命令，如果脚本的命令不是 start，想要在命令中运行时，需要这样用 npm run name 如 npm run dev ，我们在命令中输入 npm start。这样就可以开始打包文件了。 使用webpack构建本地服务器想不想让你的浏览器监听到代码的修改，并自动刷新显示修改之后的结果，其实webpack提供了一可选的本地开发服务穷，这个本地服务器是寄语node.js构建的，可以实现你想要的这些功能，不过他是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖。 1npm install webpack-dev-server --save-dev devserver配置项 功能描述 contentBase 默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public”目录） port 设置监听端口，如果省略，默认为8080 inline 设置为true，当源文件改变时会自动刷新页面 historyApiFallback 在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html 把这些命令添加到 webpack的配置文件中，现在的配置文件 webpack.config.js 123456789101112module.exports = &#123; entry: __dirname + \"/app/main.js\",//已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/public\",//打包后的文件存放的地方 filename: \"bundle.js\"//打包后输出文件的文件名 &#125;, devServer: &#123; contentBase: \"./public\",//本地服务器所加载的页面所在的目录 historyApiFallback: true,//不跳转 inline: true//实时刷新 &#125;&#125; 在package.json中的scripts对象中添加如下命令，用来开启本地服务器。 12345\"script\":&#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"webpack\", \"server\": \"webpack-dev-server --open\"&#125; 在终端中输入 npm run server即可在本地 8080端口查看到结果。 loader通过使用不同的loader，webpack有能力调用外部的脚本或者是工具，实现对不同格式文件的处理，比如说分析转换scss为css，或者把下一代的js文件转换为现代浏览器兼容的js文件，对react的开发而言，合适的loader可以把React中的用到的JSX文件转换为JS文件。loader需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，loaders的配置项包括以下几个方面。 test： 一个用来匹配loader所处理文件的扩展名的正则表达式(必须) loader：loader的名称(必填) include/exclude：手动添加必须处理的文件(文件夹)或屏蔽不需要处理的文件(文件夹)（可选） query：为loader提供额外的设置选项（可选） 在配置loader之前，我们把Greeter.js里的问候消息放在一个单独的json文件里，并通过合适的配置是 Greeter.js可以读取改json文件的值，个文件修改代码如下： 123&#123; \"greetText\":\"this is greet from json\"&#125; 更新后的Greeter.js 123456let config = require('./config.json');module.exports = function() &#123; let greet = document.createElement('div'); greet.textContent = config.greetText; return greet;&#125;; Babel的安装与配置Babel其实是几个模块的包，其核心功能位于称为 babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或扩展，你需要安装单独的包（用的做多解析es6的babel-env-preset包和解析JSX的babel-preset-react包） 我们先来一次性安装这些安装包 12// npm一次性安装多个依赖模块，模块之间用空格隔开npm install --save-dev babel-core babel-loader babel-preset-env babel-preset-react 在webpack中配置babel的方法如下 12345678910111213141516module: &#123; rules: [ &#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\", options: &#123; presets: [ \"env\", \"react\" ] &#125; &#125;, exclude: /node_modules/ &#125; ] &#125; 现在webpack的配置已经允许你使用ES6以及JSX的语法了。继续上面的例子进行测试，这是我们使用React，先安装React和React-DOM 1npm install --save-dev react react-dom 接下来我们使es6的语法，更新 Greet.js 并返回一个React组件 1234567891011121314import React, &#123;Component&#125; from 'react'import config from './config.json';class Greeter extends Component&#123; render() &#123; return ( &lt;div&gt; &#123;config.greetText&#125; &lt;/div&gt; ); &#125;&#125;export default Greeter 修改main.js如下，使用es6的模块定义和渲染Greeer模块 12345import React from 'react';import &#123;render&#125; from 'react-dom';import Greeter from './Greeter';render(&lt;Greeter /&gt;, document.getElementById('root')); 重新使用npm start打包，如果和之前打开的本地服务器没关，我们可以在localhost:8080下面看到与之前一样的内容。这说明es6和react正常打包了。 babel的配置babel其实可以完全在 webpack.config.js中进行配置，但是考虑到babel具有非常多的配置项，在单一的 webpack.config.js文件中配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置项放在一个单独的名为.babelrc的配置文件中。我们现在的babel的配置配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分俩个配置文件进行配置(webpack会自动调用1.babelrc里面babel配置选项),如下： 12345678910111213141516171819202122232425262728293031// webpack.config.jsmodule.exports = &#123; entry: __dirname + \"/app/main.js\",//已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/public\",//打包后的文件存放的地方 filename: \"bundle.js\"//打包后输出文件的文件名 &#125;, devtool: 'eval-source-map', devServer: &#123; contentBase: \"./public\",//本地服务器所加载的页面所在的目录 historyApiFallback: true,//不跳转 inline: true//实时刷新 &#125;, module: &#123; rules: [ &#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125; ] &#125;&#125;;// .babelrc&#123; \"presets\":[\"react\",\"env\"]&#125; 到目前为止，我们已经知道了，对于模块，webpack提供了非常强大的处理功能，那那些是模块呢？ 一切皆模块webpack有一个不可不说的优点，他把所有 的文件都当做模块处理，javascript代码，css和fonts以及图片等等通过核实的loader都可以被处理。 csswebpack提供了俩个工具处理样式表，css-loader 和 style-loader, 二者的处理任务不同，css-loader使你能够使用类似 @import 和 url() 的方式实现 required的功能，style-loader将所有的计算后的样式加入到页面中，二者组合在一起是你能够把样式表嵌入webpack打包后的js文件中。 12// 安装npm intall --save-dev style-loader css-loader 123456789101112131415161718192021222324252627 // 使用 module.exports = &#123; ... module: &#123; rules: [ &#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\" &#125; ] &#125; ] &#125;&#125;; 在app文件夹里创建一个名字为main.css的文件，对一些元素设置样式 1234567891011121314151617181920/* main.css */html &#123; box-sizing: border-box; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%;&#125;*, *:before, *:after &#123; box-sizing: inherit;&#125;body &#123; margin: 0; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;&#125;h1, h2, h3, h4, h5, h6, p, ul &#123; margin: 0; padding: 0;&#125; 我们这里例子中用到的webpack只有单一入口，其他的模块需要通过import,require,url等与入口文件建立起关联，为了让webpack能找到main.css我们把它导入main.css中，如下： 12345678// main.jsimport React from 'react';import &#123;render&#125; from 'react-dom';import Greeter from './Greeter';import './main.css';//使用require导入css文件render(&lt;Greeter /&gt;, document.getElementById('root')); 通常情况下，css会和js打包到同一个文件下，并不会打包为一个单独的css文件，不过通过合适的配置webpack也可以把css打包为单独的文件。 上面的代码说明webpack是怎么把css当做模块看待，接下来继续看一个更加真实的css模块实践。 css module在过去的几年里，Javascript通过一些新的语言特性，更好的工具以及更好的实践方法(比如模块化)发展的非常迅速。模块化使得开发者把复杂的代码转化为更小的，干净的，依赖声明明确的单元，配合优化工具，依赖管理和加载管理可以自动完成。 不过前端的另外部分，css发展就相对慢一些，大多的样式表却依旧巨大且充满了全局类名，维护和修改都非常的困难。 被称为css module的技术意在把js的模块化思想带入到css中来，通过css模块，所有的类名，动画名默认都之作用于当前模块。只需要在css loader中进行简单配置即可，然后就可以直接把css的类名传递到组件的代码中，这样做有效避免了全局污染。具体代码： 123456789101112131415161718192021222324252627282930module.exports = &#123; ... module: &#123; rules: [ &#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\", options: &#123; modules: true, // 指定启用css modules localIdentName: '[name]__[local]--[hash:base64:5]' // 指定css的类名格式 &#125; &#125; ] &#125; ] &#125;&#125;; 我们在app文件夹下创建一个Greet.css文件来进行测试 123456/*Greet.css */.root &#123; background-color: #eee; padding: 10px; border: 3px solid #ccc;&#125; 导入.root到Greet.js中 12345678910111213import React, &#123;Component&#125; from 'react';import config from './config.json';import styles from './Greeter.css';//导入class Greeter extends Component&#123; render() &#123; return ( &lt;div className=&#123;styles.root&#125;&gt; //使用cssModule添加类名的方法 &#123;config.greetText&#125; &lt;/div&gt; ); &#125;&#125; 放心使用，相同的类名也不会造成不同组件在之间的污染。 css预处理器sass和less之类的预处理器是对原生css的拓展，它允许你使用变量嵌套混合等不存在与css中的特性来写css，css预处理器可以将这些特殊类型的语句转化为浏览器可识别的css语句。 接下来我们在webpack中使用相关的loader进行相关的配置就可以使用了，一下是常用的css处理loaders： Less loader Sass loader Stylus loader 也存在一个处理css的平台-PostCSS，他可以帮助你的css实现更多的功能，在[官方文档]: (https://github.com/postcss/postcss) 可了解更多知识。 我们来使用 PostCSS为css代码自动添加适应不同浏览器的css前缀。 首先安装 postss-loader和autoprefixer（自动添加前缀的插件）npm install --save-dev post-loader autoprefixer 接下来，在webpack配置文件中添加 postcss-loader，在根目录新建 postcss.config.js，并添加如下代码之后，重新npm start打包时，你写的css会自动添加不同的前缀。 12345678910111213141516// webpack.config.js&#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\", options: &#123; modules: true &#125; &#125;, &#123; loader: \"postcss-loader\" &#125; ] &#125; 1234567// postcss.config.jsmodule.exports = &#123; plugins:[ require('autoprefixer') ]&#125; 1234567891011// 处理scss&#123; test: /\\.scss$/, use: [&#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\" &#125;, &#123; loader: \"sass-loader\", &#125;] &#125; 图片处理 安装库 npm i --save-dev url-loader file-loader 相应配置 1234567891011121314151617&#123; // 图片格式正则 test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use: [ &#123; loader: 'url-loader', // 配置 url-loader 的可选项 options: &#123; // 限制 图片大小 10000B，小于限制会将图片转换为 base64格式 limit: 10000, // 超出限制，创建的文件格式 // build/images/[图片名].[hash].[图片格式] name: 'images/[name].[hash].[ext]' &#125; &#125; ] &#125; 至此，本文已经谈论了处理js的babel和处理css的PostCSS的基本用法，他们其实也是俩个独立的平台，配合webpack可以很好地发挥他们的作用。接下来介绍webpack中的另一个非常重要的功能——插件。 插件(plugins)插件是用来扩展webpack功能的，他们会在整个构建过程中生效，执行相关的任务。loader和plugin常常被弄混，但是他们其实是完全不同的东西，可以这么说，loader是在打包构建工程中用来处理源文件的(less,sass,jsx)，一次处理一个，插件并不直接操作单个文件，他直接对整个构建过程起作用。 webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。 使用插件方法要使用某个插件，我们需要通过npm安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续上面的例子，我们添加了一个给打包后代码添加版权声明的插件。 12345module.exports = &#123; plugins: [ new webpack.BannerPlugin('版权所有，翻版必究') ] &#125; 这是webpack插件的基本用法，下面给大家推荐几个常用插件。 HtmlWebpackPlugin这个插件的作用是依据一个简单的index.html模板，生成一个自动引用你打包后js文件的新index.html。这在每次生成的js文件名称不同时非常有用。 安装1npm install --save-dev html-webpack-plugin 这个插件自动完成了我们之前手动做的一些事情，在正式使用之前需要对一直以来的项目结构做一些更改： 移除public文件夹，利用此插件，index.html文件会自动生成，此外css已经通过前面的操作打包到js中了。 在app目录下，创建一个index.tmpl.html文件模板，这个模板包含title等必须元素，在编译过程中，插件会依据此模板生成最终的html页面， 会自动添加所依赖的css，js，favicon等文件，index.temp.html中的模板源代码如下： 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='root'&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 更新webpack的配置文件，方法同上，新建一个build文件夹用来存放最终的输出文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: __dirname + \"/app/main.js\",//已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/build\", filename: \"bundle.js\" &#125;, devtool: 'eval-source-map', devServer: &#123; contentBase: \"./public\",//本地服务器所加载的页面所在的目录 historyApiFallback: true,//不跳转 inline: true//实时刷新 &#125;, module: &#123; rules: [ &#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\", options: &#123; modules: true &#125; &#125;, &#123; loader: \"postcss-loader\" &#125; ] &#125; ] &#125;, plugins: [ new webpack.BannerPlugin('版权所有，翻版必究'), new HtmlWebpackPlugin(&#123; template: __dirname + \"/app/index.tmpl.html\"//new 一个这个插件的实例，并传入相关的参数 &#125;) ],&#125;; 再次执行 npm start ，build文件夹下生成了 bundle.js index.html。 产品阶段构建目前为止，我们已经使用webpack构建了一个完整的开发环境。但是在产品阶段，可能还需要对打包的文件进行额外的处理，比如说：优化，压缩，缓存以及分离css和js。对于复杂的项目来说，需要复杂的配置，这时候分解配置文件为多个小文件可以使得事情井井有条，以上面的例子来看，我们创建一个 webpack.production.config.js文件，在里面加上基本的配置，他和原始的webpack.config.js很像，如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// webpack.production.config.jsconst webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: __dirname + \"/app/main.js\", //已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/build\", filename: \"bundle.js\" &#125;, devtool: 'null', //注意修改了这里，这能大大压缩我们的打包代码 devServer: &#123; contentBase: \"./public\", //本地服务器所加载的页面所在的目录 historyApiFallback: true, //不跳转 inline: true, hot: true &#125;, module: &#123; rules: [&#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: \"style-loader\", use: [&#123; loader: \"css-loader\", options: &#123; modules: true &#125; &#125;, &#123; loader: \"postcss-loader\" &#125;], &#125;) &#125;] &#125;, plugins: [ new webpack.BannerPlugin('版权所有，翻版必究'), new HtmlWebpackPlugin(&#123; template: __dirname + \"/app/index.tmpl.html\" //new 一个这个插件的实例，并传入相关的参数 &#125;), new webpack.HotModuleReplacementPlugin() //热加载插件 ],&#125;; 12345678910111213141516171819202122// package.json&#123; \"name\": \"test\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"webpack\", \"server\": \"webpack-dev-server --open\", \"build\": \"NODE_ENV=production webpack --config ./webpack.production.config.js --progress\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123;... &#125;, \"dependencies\": &#123; \"react\": \"^15.6.1\", \"react-dom\": \"^15.6.1\" &#125;&#125; 如果是window电脑，build需要配置为 &quot;build&quot;: &quot;set NODE_ENV=production &amp;&amp; webpack --config ./webpack.production.config.js --progress&quot; 优化插件webpack提供了一些在发布阶段非常有用的一些插件，他们大多来自webpack社区，可以通过npm安装，通过以下插件可以在完成产品发布阶段所需的功能 OccurenceOrderPlugin :为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID UglifyJsPlugin:压缩js代码 ExtractTextPlugin:分离css和js文件 OccurenceOrder 和 UglifyJS plugins 都是内置插件，你需要做的只是安装其它非内置插件 1npm install --save-dev extract-text-webpack-plugin 在配置文件的plugins后启用他们 1234567891011121314151617// package.json// const ExtractTextPlugin = require('extract-text-webpack-plugin');const UglifyJsPlugin = require('uglifyjs-webpack-plugin');module.exports = &#123; ... plugins: [ new webpack.BannerPlugin('版权所有，翻版必究'), new HtmlWebpackPlugin(&#123; template: __dirname + \"/app/index.tmpl.html\" &#125;), new UglifyJsPlugin(), // new webpack.optimize.OccurrenceOrderPlugin(), //new webpack.optimize.UglifyJsPlugin(), // new ExtractTextPlugin(\"styles.css\") ], &#125; 此时执行npm run build可以看见代码是被压缩后的。","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]}]